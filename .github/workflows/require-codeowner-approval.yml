# .github/workflows/require-codeowner-approval.yml

# Name of the workflow
name: 'Require Code Owner Approval'

# This workflow runs when a pull request is opened, updated, or a review is submitted.
on:
  pull_request:
    types: [opened, reopened, synchronize]
  pull_request_review:
    types: [submitted, dismissed]

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This job checks for code owner approval
  check_code_owner_approval:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    steps:
      # We use the official checkout action to get access to the repository files,
      # including the CODEOWNERS file.
      - name: Checkout repository code
        uses: actions/checkout@v4

      - name: Verify Code Owner Approval
        uses: actions/github-script@v7
        with:
          # The GITHUB_TOKEN is automatically passed to github-script
          script: |
            const fs = require('fs');
            const minimatch = require('minimatch');
            const { owner, repo } = context.repo;
            const prNumber = context.issue.number;

            // --- 1. Get Changed Files ---
            core.info('Fetching changed files...');
            const { data: changedFiles } = await github.rest.pulls.listFiles({
              owner,
              repo,
              pull_number: prNumber,
            });
            const filepaths = changedFiles.map(f => f.filename);
            if (filepaths.length === 0) {
              core.info('No file changes detected. Skipping check.');
              return;
            }
            core.info(`Changed files: ${filepaths.join(', ')}`);

            // --- 2. Read and Parse CODEOWNERS file ---
            const codeownersPath = '.github/CODEOWNERS';
            if (!fs.existsSync(codeownersPath)) {
              core.info('No CODEOWNERS file found. Skipping check.');
              return;
            }
            const codeownersContent = fs.readFileSync(codeownersPath, 'utf8');
            const codeownerLines = codeownersContent.split('\n').filter(line => line && !line.startsWith('#'));
            
            const requiredOwners = new Set();
            for (const path of filepaths) {
              // Find the last matching rule for the file path
              let lastMatch = null;
              for (const line of codeownerLines) {
                const [pattern] = line.split(/\s+/);
                if (minimatch(path, pattern)) {
                  lastMatch = line;
                }
              }

              if (lastMatch) {
                const owners = lastMatch.trim().split(/\s+/).slice(1);
                owners.forEach(owner => requiredOwners.add(owner.replace('@', '')));
              }
            }

            if (requiredOwners.size === 0) {
              core.info('No code owners found for the changed files. Passing.');
              return;
            }

            // --- 3. Expand Teams into Individual Members ---
            const finalOwnerSet = new Set();
            for (const owner of requiredOwners) {
              if (owner.includes('/')) {
                // This is a team
                const [org, team_slug] = owner.split('/');
                core.info(`Fetching members for team @${owner}...`);
                try {
                  const { data: members } = await github.rest.teams.listMembersInOrg({ org, team_slug });
                  members.forEach(member => finalOwnerSet.add(member.login));
                } catch (error) {
                  core.warning(`Could not fetch members for team @${owner}. Error: ${error.message}`);
                }
              } else {
                // This is an individual user
                finalOwnerSet.add(owner);
              }
            }

            if (finalOwnerSet.size === 0) {
              core.info('No code owners could be resolved. Passing.');
              return;
            }
            core.info(`Required approvers for this PR: ${Array.from(finalOwnerSet).map(o => `@${o}`).join(', ')}`);

            // --- 4. Get All Approvers for the PR ---
            core.info('Fetching reviews for the pull request...');
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner,
              repo,
              pull_number: prNumber,
            });

            const latestReviews = {};
            // Sort reviews to process from oldest to newest
            reviews.sort((a, b) => new Date(a.submitted_at) - new Date(b.submitted_at));
            for (const review of reviews) {
              if (review.state === 'APPROVED' || review.state === 'CHANGES_REQUESTED') {
                latestReviews[review.user.login] = review.state;
              }
            }

            const approvers = Object.keys(latestReviews).filter(user => latestReviews[user] === 'APPROVED');
            core.info(`Found approvers: ${approvers.length > 0 ? approvers.map(a => `@${a}`).join(', ') : 'None'}`);

            // --- 5. Compare Owners and Approvers ---
            const hasApproval = approvers.some(approver => finalOwnerSet.has(approver));

            if (hasApproval) {
              core.info('SUCCESS: Found valid approval from a code owner.');
            } else {
              core.setFailed(`FAILURE: No approval from a required code owner. This PR requires approval from one of: ${Array.from(finalOwnerSet).map(o => `@${o}`).join(', ')}`);
            }
